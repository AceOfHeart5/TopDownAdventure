I can't explain why, but I like the idea of having an easier way of making a different variety of attacks in this game. Heck, I'm not even sure I want the game to have "attacks", which should give us an idea of how flexible a system I'm aiming for. But what I'm thinking is that the same system that generates and responds to hitboxes could also be used for something like... blowing a character with wind, or freezing them in place, or basically whatever we want. I've read in a number of places that a "event handling system" might be the best way to go about this. 

So if I understand that right, instead of having a piece of code that detects whether or not it has collided with an actor, and then telling that actor what to do, we'll have a system where something detects if it has collided with an actor, and then generates an "event" with all of the necessary data. Then later the actor will search for any "events" that target it, and respond to them. 

So for hitboxes, we could have "hit" events generated by the hitboxes. And the Actors could have "hurt" states that search through the game each step to see if their is a "hit" event targetting that actor. If there is, bam, actor enters the hurt state and does what it needs to. We could have something in the game world that's like a giant fan that blows things around. This fan could generate "blow" events that target certain actors. The actors could have a state "blown" which looks for "blow" events targetting the actors, and if it finds one, moves the actor around a little bit. Here's the steps in code as I'm imagining them:

Check state connections and switch
Run state code
States that check events check for events and switch

So if I've got it right, this should cover any issues with weird stuff like "blow" events or "hit" events causing states to switch out of place.

The thing is, in a lot of ways it makes sense to have state code run after checking for events. Or better yet, checking for events is part of the check state connections step. BUT, we don't want to make states the only thing that respond to events. Consider being on fire. We want characters to still be able to do all their normal actions, except their health is depleting and they're on fire. It doesn't make sense to have "on fire" be its own state checking for events. Or the blow event, the character should still be able to walk around and attack or whatever, but have their x position gently nudged 0.2 units to the left every step.  

Actually... there's something fairly significant. If we have something like "blow" that moves the player around, but we've already had a bunch of issues with non-integer values, and the blow event moves them 0.2 units after their state code has already executed... How do we ensure actors only use integer values?? I think we may need to revisit our position system. Actors will likely need their own separate x/y that states modify. And these values are rounded before before being assigned to the game maker x/y.

We began to actually implement this other x/y change, where the actor holds a different x/y from game maker. We realized that we can't have the actor update its position in its own logic loop. It probably has to be done in the master loop. This is because things like hitbox generation will be created in actor logic step. It's in the actor event handling step that actors will get hit and blown around. THEN, we can set actors to their integer x/y positions. So, I think the Master loop has to handle actor x/y.

So I think I understand how we're going to get actors responding to hitboxes. And I bet we can use the same design principles for things like shields if we decide to try that later. The thing to figure out now is how are we going to actually get hitboxes out into the game world? Here's my plan, we have o_attack objects that store a bunch of data on hitboxes. That data is stuff like, what hitboxes, how many, where to put them, where to move them, and when to delete them. Ok actually... maybe not that much data. As I think about this, it'll probably be much easier to just create and delete hitboxes, and maybe move all of them, but not given individual movement patterns to them. I'm imagining the attack object would have a list, or array of hitbox "patterns" or something like that. And the attack object would each frame, change the hitbox patter to whatever patter is stored next in the array. That way I could pick the exact shape of a hitbox pattern for each frame of an attack. Except... that means deleting and remaking hitboxes for each frame of an attack. That seems kinda messy?

Ok, what about this instead... attacks don't actually have lists, array, or any sort of real means to keep track of hitboxes. What if the hitboxes keep track of their own data. By that I mean their own start up lag, exist time, and position. We could use variables for the times, and a grid for the x/y positions for each frame. So the attack object itself, all it does is store the creation code for these hitboxes. It means that each attack would essentially be a bunch of: with (instance_create(hitbox)). The one real thing the attack object would do, is give each hitbox a unifying ID. That way actors could check if the hitbox they're getting hit by is already a part of the same attack. This way we can have lazy hitbox creation, stuff like overlapping hitboxes, and actors won't recieve multiple, undeserved hits. 

I'm just realizing that we'll want to have projectiles, and hitboxes of projectiles won't need complicated position, frame matching nonsense. I'm pretty sure I can just add variables to the hitbox object that makes it behave differently. We could probably make a TYPE enumerator that determines how the hitbox behaves, and a switch statement in the update event that tells it what to do.

We need to remind ourself how our system works... because I think we should implement hurt boxes in this game. Given our interests, fighting game mechanics are likely going to be integral parts of our games for a long time. The basic building blocks of a fighting game are hitboxes and hurtboxes. There's also blocking, and world collision boxes, but I'm not going to worry too much about blocking in this particular game since I think blocking is going to vary from game to game. Hitbox and hurtbox though... those are essentially the same everywhere.

So how to do hurtboxes? Let's review the current plan:
o_attack creates hitboxes
hitboxes detect their target, and create a hitbox event if they collide. 
The hurt state of actors (which always run for actors), detect, process, and respond to the events.

So that makes sense... but how do we make this work with hurtboxes? First we should think about how hurtboxes work in relation to actors. The idea is that there would be a "map" of hurboxes for each sprite, so the actor actually vulnerable where they appear to be in-game. This is kind of tricky because the sprites are dictated by the different states, and for the sake of clean design, we don't want code about getting in states that don't involved getting hurt. Here's one solution. The hurt state contains a map. This map uses sprite IDs as keys, and arrays of hurboxes as values. During hurt state check step, the state checks the map for the actors current sprite, and then uses the hurtbox data at that spot in the map to determine if it's been hit.

Ok, so actually, to keep things more organized, it makes more sense for the actors, or more specifically the hurtboxes, to check for hitboxes than the other way around. That way, we don't need the hitbox to check if the actor even has a hurt state. Also the hitbox would have to iterate over the actors hurtboxes. It makes more sense for so much code relating to the hurtboxes to be stored in the state that deals with them. So let's summarize our new plan:

Actors update positions and states. Always check states run their checks (this includes hurt state). Hurt state uses hurtbox map for current sprite to check for collision with hitbox that targets actor. If there is, set actor to hurt state. 

We should read this later, it was linked by a discord user: https://www.gamasutra.com/blogs/NahuelGladstein/20180514/318031/Hitboxes_and_Hurtboxes_in_Unity.php