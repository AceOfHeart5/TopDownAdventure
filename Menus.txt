Our last system for menus was terrible. It was spaghetti and confusing. Adding new menu options was hard just because I didn't understand my own code. We need to think of a better system for this one. So let's make a menu object that acts as a parent object. We'll update it in the same way we update actors (by using the user events). Perhaps we could even make the menu options themselves be objects? We could think of menus as like actors, and options as like states. Actually that's kind of silly... because we're not going to run different code every frame for the menu depending on the option. But we WILL run different code depending on the menu choice. Ok... so maybe they should be separate objects. The menus will just have "choice" objects that we add to it in the create event. These choices are actual objects run code (a user event). We could have variables/scripts/events that return a true or false depending on whether or not the "choice" has finished what it needs to do. This would allow us to do things like have a choice that just spawns a new menu... and it's "done" function (or whatever we decide to call these) will return true when the menu is closed. 

Something to keep in mind is where to position everything so that button presses are not registered for sub menus. In our previous project, that was a big issue. So if we pressed "select" on "sound options", the sound menu would open with the first option already being treated as if we'd pressed "select". I'm quite sure we can avoid this simply by executing choice code before we open new menus. Actually... wait, no. We're going to just loop through all instances of menu objects to do this. If we create a new menu, then the code is going to loop through to the next menu.... we should try making a loop that decrements through all the instance numbers instead of incrementing. But what happens if we delete a menu??? Oh wait... I know what to do. We don't create or delete menus at all. We'll create a menu variable "active". And only execute its code if it is active. 

Ah, actually, yes. We'll have two variables "active" and "start". In code, activating a menu will only set its "start" variable to true. But in the end step of menus, we'll have active set to true if start has been set true (and remember to set start to false each frame regardless). This way activating a sub menu won't run its logic until the next frame, but we can still have menus respond the same frame that a button is pressed. 

Haha... ya know what? We should make text boxes for this game first. Or maybe we don't? One of the main things textboxes do for us is line wrap and type. We're not going to worry about those things with menus. So I guess we can just draw text everything. 

I'm going to ramble about menus and input for a second. I'm forgetting my vocabulary, but I believe the term for the environment in a piece of software that's listening to your inputs as the the element with "focus". For example, even though I have game maker, firefox, and discord all open at the same time, only the program with "focus" is paying attention to my mouse and keyboard. It's a concept to common and simple I forget about it. We talked about this above a bit, but we need a way to make sure our menus, and the game world, maintain "focus" correctly...

Currently, we simply have actors only execute their code if freeze_time is 0, and there are no objects in the freeze actors list. Activating the pause menu adds the pause menu object to the list of actor freezers. This system works fine for toggling between two things that want focus (the game world and the pause menu). But once we have things like sub menus, or maybe even in-game minigames, we'll need something more elegant. 

So here's a first idea: we move a lot of the code of the o_master object out into an o_gameworld object. The gameworld object will loop through actors and enemies, and run their code. The master object will, instead, cointain a variable called "focus" or something like that, and only update that game object. So as an example, the game starts with the title menu as the focus object. If from the title the player selects "options", then the options menu becomes the focus object. If the player starts the game, then the gameworld object becomes the focus object. We can still have actor freezers and freeze time (we need freeze time for hitstun), but now the pause menu and other such things won't be actor freezers. We can then create scripts that change the game focus object to... literally whatever. 

I like that idea, but I suppose a big question is what actually changes the focus? Does the master do it? Or do I let the individual pieces of the game say what should be the focus? I'm tempted to let the individual pieces change focus just because it'll easier to build, even if it's more difficult to keep organized. 

Been working with it and I think we've figure out a lot. This next step makes sense but I'm going to write it down anyway so it's so easy to lose track of whats going on. We're going forward with our focus idea, but the focus variable will instead be a stack, and the master object will update the top element of the stack. When the top object no longer wants to be the game focus, it stimply pops itself off. This makes it easy to make things like confirmation boxes, which will simply pop off the stack once a decision is made, and the menu below will magically regain focus and can read the decision. 