Our last system for menus was terrible. It was spaghetti and confusing. Adding new menu options was hard just because I didn't understand my own code. We need to think of a better system for this one. So let's make a menu object that acts as a parent object. We'll update it in the same way we update actors (by using the user events). Perhaps we could even make the menu options themselves be objects? We could think of menus as like actors, and options as like states. Actually that's kind of silly... because we're not going to run different code every frame for the menu depending on the option. But we WILL run different code depending on the menu choice. Ok... so maybe they should be separate objects. The menus will just have "choice" objects that we add to it in the create event. These choices are actual objects run code (a user event). We could have variables/scripts/events that return a true or false depending on whether or not the "choice" has finished what it needs to do. This would allow us to do things like have a choice that just spawns a new menu... and it's "done" function (or whatever we decide to call these) will return true when the menu is closed. 

Something to keep in mind is where to position everything so that button presses are not registered for sub menus. In our previous project, that was a big issue. So if we pressed "select" on "sound options", the sound menu would open with the first option already being treated as if we'd pressed "select". I'm quite sure we can avoid this simply by executing choice code before we open new menus. Actually... wait, no. We're going to just loop through all instances of menu objects to do this. If we create a new menu, then the code is going to loop through to the next menu.... we should try making a loop that decrements through all the instance numbers instead of incrementing. But what happens if we delete a menu??? Oh wait... I know what to do. We don't create or delete menus at all. We'll create a menu variable "active". And only execute its code if it is active. 

Ah, actually, yes. We'll have two variables "active" and "start". In code, activating a menu will only set its "start" variable to true. But in the end step of menus, we'll have active set to true if start has been set true (and remember to set start to false each frame regardless). This way activating a sub menu won't run its logic until the next frame, but we can still have menus respond the same frame that a button is pressed. 

Haha... ya know what? We should make text boxes for this game first. Or maybe we don't? One of the main things textboxes do for us is line wrap and type. We're not going to worry about those things with menus. So I guess we can just draw text everything. 

I'm going to ramble about menus and input for a second. I'm forgetting my vocabulary, but I believe the term for the environment in a piece of software that's listening to your inputs as the the element with "focus". For example, even though I have game maker, firefox, and discord all open at the same time, only the program with "focus" is paying attention to my mouse and keyboard. It's a concept to common and simple I forget about it. We talked about this above a bit, but we need a way to make sure our menus, and the game world, maintain "focus" correctly...

Currently, we simply have actors only execute their code if freeze_time is 0, and there are no objects in the freeze actors list. Activating the pause menu adds the pause menu object to the list of actor freezers. This system works fine for toggling between two things that want focus (the game world and the pause menu). But once we have things like sub menus, or maybe even in-game minigames, we'll need something more elegant. 

So here's a first idea: we move a lot of the code of the o_master object out into an o_gameworld object. The gameworld object will loop through actors and enemies, and run their code. The master object will, instead, cointain a variable called "focus" or something like that, and only update that game object. So as an example, the game starts with the title menu as the focus object. If from the title the player selects "options", then the options menu becomes the focus object. If the player starts the game, then the gameworld object becomes the focus object. We can still have actor freezers and freeze time (we need freeze time for hitstun), but now the pause menu and other such things won't be actor freezers. We can then create scripts that change the game focus object to... literally whatever. 

I like that idea, but I suppose a big question is what actually changes the focus? Does the master do it? Or do I let the individual pieces of the game say what should be the focus? I'm tempted to let the individual pieces change focus just because it'll easier to build, even if it's more difficult to keep organized. 

Been working with it and I think we've figure out a lot. This next step makes sense but I'm going to write it down anyway so it's so easy to lose track of whats going on. We're going forward with our focus idea, but the focus variable will instead be a stack, and the master object will update the top element of the stack. When the top object no longer wants to be the game focus, it stimply pops itself off. This makes it easy to make things like confirmation boxes, which will simply pop off the stack once a decision is made, and the menu below will magically regain focus and can read the decision. 

Menus have turned out a bit more spaghetti than I'd like, but they work, and I understand them (mostly), so we'll move forward. We need to think about tooltips, the little icons showing what buttons to press to do what. Actually... there are just a few fringe cases where this is an issue (controls menu), and we should be able to just code stuff case-by-case instead of building a larger system to handle stuff. 

We have one more menu to make (for this project), and that's the main menu. Weirdly enough our structure doesn't make it immediately obvious how to incorporate the main menu. My first instinct is to put it in its own room, and the script that gets us to this room sets the main menu as the focus object. However, our focus loop permits pausing. Do we make an ugly "can pause" variable that the pause menu checks? Do we try and re-work our game loop so that the pause menu does not surround the main loop?? Actually, yeah, that wouldn't be too bad. We can just make a switch statement,  for "main menu" and "in-game". And if we're in the main menu then we're just updating the main menu. Except, we're going to have focus objects that take us to the main menu, right? So how do we allow objects like that to keep focus until their finished, and only when they're done do they give focus to the main menu. 

Maybe we should just make multiple layers of focus object. We have the master object with its own focus that it updates. Then, we have a "game" object that has its own focus, and this is the object that will check against the pause menu before updating the gameworld. And then finally there's the game world... oh wait the game world doesn't have a focus object, it IS a focus object. Let's try that system. 

Ok so the problem with that system is that the menus are all built around pushing and popping focus, And now we have two different focuses, the master focus and the game focus. Obviously we can just changed all the menus to use game focus, but then for menus that deal with master focus (like the main menu), we'd have to make exact copies where the only difference is whether they call focus_game vs focus_master. Perhaps I'm over complicating this... what if all we did was use the old single focus system, but we just wrap the gameworld in the game object? And all the game object ever does is update the gameworld, or push focus to the pause menu? That's basically what the old system was, but with the master object taking the place of our soon-to-be game object. Let's try that. 

That didn't work either... or I guess one could argue it worked, but it would not allow us to pause the game at any point in time. We want to be able to pause Literally at any point. I don't have a specific reason for this, I just prefer to have that level of control over the game world. So let's give up on trying to be clean. Let's just put some disgusting switch statement in the master object that updates the main menu if we're in the main menu room, otherwise it behaves like it did before. 